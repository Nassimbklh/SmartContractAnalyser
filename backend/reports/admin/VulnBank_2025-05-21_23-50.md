# üìÑ Rapport d'analyse de contrat intelligent

**Nom du fichier :** VulnBank_2025-05-21_23-50  
**Nom du contrat :** VulnBank  
**Adresse d√©ploy√©e :** 0xF2E246BB76DF876Cef8b38ae84130F4F55De395b  
**Compilateur Solidity :** 0.8.0  
**Date d‚Äôanalyse :** 2025-05-21 23:50  

---

## ‚úÖ R√©sultat global

**Statut :** ‚ùå KO ‚Äì Vuln√©rabilit√© d√©tect√©e  
**Type de vuln√©rabilit√© :** Reentrancy Attack

---

## üîç R√©sum√© de l‚Äôanalyse

**Reentrancy via deposit() during withdraw() fallback:**

- The contract sets the balance to zero before sending ETH in `withdraw()`, preventing reentrancy on `withdraw()` itself.
- However, the ETH transfer uses `call`, which forwards all gas and triggers the fallback on the attacker contract.
- The attacker contract's fallback calls `deposit()` to increase its balance again during the withdrawal.
- After the first withdrawal completes, the attacker calls `withdraw()` again to withdraw the newly deposited balance.
- This cycle can be repeated multiple times, allowing the attacker to withdraw multiple times their initial deposit.
- This is a classic reentrancy attack exploiting the fact that `deposit()` is callable during the fallback and modifies the balance.

---

3.

---

## üß† Raisonnement du mod√®le

The contract `VulnBank` is a simple ETH bank allowing users to deposit and withdraw their funds. The key functions are:

- `deposit()`: increases the sender's balance by the sent ETH amount.
- `withdraw()`: reads the sender's balance, requires it to be > 0, sets it to zero, then sends the ETH back using a low-level call.

The withdrawal pattern is:

```solidity
uint256 amount = balances[msg.sender];
require(amount > 0);
balances[msg.sender] = 0;
(bool success, ) = msg.sender.call{value: amount}("");
require(success);
```

This is the classic withdrawal pattern, where the balance is zeroed before sending ETH, which normally prevents reentrancy.

However, the call is made via `msg.sender.call{value: amount}("")`, which forwards all gas and allows the recipient to execute arbitrary code.

Since the balance is set to zero before the call, a simple reentrancy attack (calling `withdraw()` recursively) would not work because the balance is already zero.

But let's consider if there is any other vulnerability:

- The contract does not use any reentrancy guard.
- The balances mapping is public, so anyone can see balances.
- The deposit function simply adds msg.value to balances[msg.sender].
- The withdraw function sends ETH to msg.sender.

Is there any way to exploit this?

**Potential attack vector:**

- The contract uses `call` to send ETH, which forwards all gas and allows reentrancy.
- The balance is set to zero before the call, so reentrancy on `withdraw()` itself is prevented.
- But what if the attacker can call `deposit()` during the reentrant call?

Since `deposit()` is `payable` and public, the attacker contract can call `deposit()` during the fallback triggered by the `call` in `withdraw()`.

If the attacker calls `deposit()` during reentrancy, they can increase their balance again while the first `withdraw()` call is still in progress.

Then, after the first `withdraw()` finishes, the attacker can call `withdraw()` again to withdraw the newly deposited balance.

This is a **reentrancy via deposit()**.

**Attack steps:**

1. Attacker deposits some ETH to set an initial balance.
2. Attacker calls `withdraw()`.
3. During the `msg.sender.call{value: amount}("")` call, the attacker contract's fallback is triggered.
4. In fallback, the attacker calls `deposit()` sending some ETH (or even zero ETH if allowed, but here deposit requires payable, so must send ETH).
5. This increases the attacker's balance again.
6. After the first `withdraw()` finishes, the attacker calls `withdraw()` again to withdraw the newly deposited balance.

This allows the attacker to "recycle" their balance multiple times by reentering deposit during withdrawal.

**Is this profitable?**

- The attacker must send ETH during deposit to increase balance.
- But the attacker can do this with zero ETH? No, deposit requires payable and adds msg.value to balance, so zero ETH deposit adds zero balance.
- So the attacker must send ETH to deposit, which is not free.

**Is there a way to exploit this to drain more ETH than deposited?**

No, because the attacker must send ETH to deposit, so they cannot create balance out of thin air.

**Is there any other vulnerability?**

- The contract does not check for integer overflow in balances, but Solidity 0.8+ has built-in overflow checks.
- The contract does not restrict who can call deposit or withdraw.
- The contract uses `call` to send ETH, which is recommended over `transfer` or `send` in Solidity 0.8+.
- The contract does not have any owner or admin functions.

**Conclusion:**

The contract is vulnerable to a **reentrancy attack via the deposit() function called during the fallback triggered by withdraw()**.

This allows the attacker to "recycle" their balance multiple times, effectively withdrawing their balance multiple times if they can deposit ETH during the fallback.

**Maximizing impact:**

- The attacker can deposit a small amount of ETH.
- Then call withdraw().
- During the fallback, call deposit() again with the same amount.
- After the first withdraw finishes, call withdraw() again.
- Repeat this process multiple times in a loop (if gas allows).

This allows the attacker to withdraw multiple times their initial deposit, draining ETH from the contract.

---

2.

---


## ‚öîÔ∏è Code d'exploit propos√©

Aucun exploit ex√©cutable g√©n√©r√©. Code incomplet ou invalide.


---

‚ö†Ô∏è **Note :** Ce rapport est g√©n√©r√© automatiquement. Il ne garantit pas l'absence totale de failles. Une revue humaine reste recommand√©e.
